# =============================================================================
# GitHub Composite Action File
# =============================================================================
# This file provides a composite action that collects common steps to be
# shared in the workflow.
# =============================================================================

#  Terraform only manages what’s recorded in its state file. If the state doesn’t
#  contain the RG, Terraform assumes it doesn’t exist and tries to create it. Azure
#  rejects that because it already exists, and Terraform tells you to import.
#
#  That means Terraform is using the local backend. In GitHub Actions, runners are
#  ephemeral, so unless you persist the state somehow, each run starts with an
#  empty state → destroy can’t destroy anything and apply tries to recreate
#  existing resources, which then fails. This is exactly why pipelines that use
#  local state on ephemeral runners often fail on the second run.
#
#  To fix the issue we need to import the existing resources (e.g., resource group,
#  storage account, and container name) into Terraform local state.

name: "Import Terraform Bootstrap Backend State"

runs:
  using: "composite"
  steps:
    - name: Import existing RG if needed (bootstrap)
      working-directory: ${{ env.WORKING_DIR }}
      shell: bash
      run: |
        set -uo pipefail
        if ! terraform state show azurerm_resource_group.tfstate >/dev/null 2>&1; then
          printf "Importing resource %s.\n" "${EXPECTED_RG_NAME}"
          # import resource group
          terraform import azurerm_resource_group.tfstate \
            "/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${EXPECTED_RG_NAME}" \
            || printf "WARN: %s import failed (continuing anyway).\n" "${EXPECTED_RG_NAME}"
        else
          printf "Resource %s already in state; skipping import.\n" "${EXPECTED_RG_NAME}"
        fi

    - name: Import existing storage account if needed (bootstrap)
      working-directory: ${{ env.WORKING_DIR }}
      shell: bash
      run: |
        set -uo pipefail
        if ! terraform state show azurerm_storage_account.tfstate >/dev/null 2>&1; then
          printf "Importing resource %s.\n" "${EXPECTED_STORAGE_ACCOUNT_NAME}"
          # import storage account
          terraform import azurerm_storage_account.tfstate \
            "/subscriptions/${ARM_SUBSCRIPTION_ID}/resourceGroups/${EXPECTED_RG_NAME}/providers/Microsoft.Storage/storageAccounts/${EXPECTED_STORAGE_ACCOUNT_NAME}" \
            || printf "WARN: %s import failed (continuing anyway).\n" "${EXPECTED_STORAGE_ACCOUNT_NAME}"
        else
          printf "Resource %s already in state; skipping import.\n" "${EXPECTED_STORAGE_ACCOUNT_NAME}"
        fi

    - name: Import existing container name if needed (bootstrap)
      working-directory: ${{ env.WORKING_DIR }}
      shell: bash
      run: |
        set -uo pipefail
        if ! terraform state show azurerm_storage_container.tfstate >/dev/null 2>&1; then
          printf "Importing resource %s.\n" "${EXPECTED_CONTAINER_NAME}"
          # import container name
          terraform import azurerm_storage_container.tfstate \
            "https://${EXPECTED_STORAGE_ACCOUNT_NAME}.blob.core.windows.net/${EXPECTED_CONTAINER_NAME}" \
            || printf "WARN: %s import failed (continuing anyway).\n" "${EXPECTED_CONTAINER_NAME}"
        else
          printf "Resource %s already in state; skipping import.\n" "${EXPECTED_CONTAINER_NAME}"
        fi

    - name: Terraform plan after imports (bootstrap)
      working-directory: ${{ env.WORKING_DIR }}
      shell: bash
      run: |
        terraform plan -out=bootstrap.tfplan
